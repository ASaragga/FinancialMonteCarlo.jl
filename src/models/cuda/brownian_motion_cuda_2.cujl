
function simulate!(X_cu,mcProcess::BrownianMotion,mcBaseData::MonteCarloConfiguration{type1,type2,type3,CudaMode_2,type5},T::numb) where {numb <: Number, type1 <: Integer, type2<: Integer, type3 <: StandardMC, type5 <: Random.AbstractRNG}
	Nsim=mcBaseData.Nsim;
	Nstep=mcBaseData.Nstep;

	σ=mcProcess.σ;
	μ=mcProcess.μ;
	@assert T>0.0
	dt=T/Nstep
	mean_bm=μ*dt
	stddev_bm=σ*sqrt(dt)
	isDualZero=mean_bm*stddev_bm*zero(Float32);
	view(X_cu,:,1).=isDualZero;
	Z=CuArray{Float32}(undef,Nsim);
	CuArrays.@sync for i=1:Nstep
		X_pr=view(X_cu,:,i);
		randn!(CURAND.generator(),Z);
		@inbounds X_cu[:,i+1]=X_pr+(mean_bm.+stddev_bm*Z);
	end
	nothing
end


function simulate!(X_cu,mcProcess::BrownianMotion,mcBaseData::MonteCarloConfiguration{type1,type2,type3,CudaMode_2,type5},T::numb) where {numb <: Number, type1 <: Integer, type2<: Integer, type3 <: AntitheticMC, type5 <: Random.AbstractRNG}
	Nsim=mcBaseData.Nsim;
	Nstep=mcBaseData.Nstep;

	σ=mcProcess.σ;
	μ=mcProcess.μ;
	@assert T>0.0
	dt=T/Nstep
	mean_bm=μ*dt
	stddev_bm=σ*sqrt(dt)
	isDualZero=mean_bm*stddev_bm*zero(Float32);
	Nsim_2=Int(floor(Nsim/2))
	for i=1:Nstep
		Z=CuArrays.CURAND.randn(Float32,Nsim_2);
		Z=[Z;-Z];
		X_cu[:,i+1]=X_cu[:,i]+(mean_bm.+stddev_bm.*Z);
	end
	return;
end

